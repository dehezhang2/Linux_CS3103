#include <iostream>
#include <cstdlib>
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <ctime>
#include <stdio.h>
#include <semaphore.h>

using namespace std;
static int maxT = 0,	// max Token
           flowInterval = 0,	//sleep interval time
           currentT = 0,	// current Token in queue
           servedT = 0,	// served Token
           dropT = 0,	// dropped Token
           totalFetchT = 0,	// total fetched Token
           totalGenT = 0,	// total generated Token
           totalPGenT = 0; // total token generated by pflow
int s;	// for mutex
sem_t empty;
static pthread_mutex_t mtx1 = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t mtx2 = PTHREAD_MUTEX_INITIALIZER;

class MyQueue {
private:
    int capacity, front, rear, seqNum;
    int *queue;
public:
    MyQueue() {
        queue = new int[10];
        front = 0;
        rear = 0;
        seqNum = -1;
        capacity = 10;
    }
    int push(int genToken) {
        int addedT = 0;
        if (capacity - currentT < genToken && servedT < maxT) {	// not enough space for storing all tokens
            dropT += (genToken - (capacity - currentT));	// dropped Token increases
            servedT += dropT; // served Token increases
            genToken = capacity - currentT;	// Token can be added
        }
        currentT += genToken;	// add Tokens into queue
        for (int i = 0; i < genToken; i++) {	// increases sequence number and generated Token
            queue[rear] = ++seqNum;
            addedT++;
            rear = (rear + 1) % capacity;
        }
        return addedT;
    }

    int pop(int fetchToken) {

        if (currentT != 0) {
            if (servedT + fetchToken >= maxT) { // Exceed Max Token after fetching
                if (servedT < maxT) {
                    fetchToken = maxT - servedT; // fetch the remaining token
                }
            }
            currentT -= fetchToken; // remove token from queue
            servedT += fetchToken; // add token into served token
            for (int i = 0; i < fetchToken; i++) { // pop tokens from queue
                front = (front + 1) % capacity;
                totalFetchT++;
            }
        }
        return fetchToken;
    }
    bool isEmpty() {
        return (front == rear);
    }
    bool isFull() {
        return ((rear + 1) % capacity == front);
    }
    int getSize() {
        int size;
        if (front < rear) {
            size = rear - front;
        } else {
            size = capacity - (front - rear);
        }
        return size;
    }
    int getSeqNum() {
        return seqNum;
    }
};

void* pflow(void *arg) {
    MyQueue *q = (MyQueue*)arg;
    int addedT = 0;
    int genT = 0;
    while (servedT < maxT) {
        sem_wait(&empty);
        if (servedT >= maxT) {
            pthread_exit(NULL);
        }
        // sem_wait(&empty);
        srand(time(NULL));
        genT = (rand() % 5) + 1;
        s = pthread_mutex_lock(&mtx1);
        s = pthread_mutex_lock(&mtx2);
        addedT = q->push(genT);
        totalPGenT += genT;
        cout << addedT << " (pflow)\t\t" << q->getSeqNum() << "\t\t\t" << q->getSize() << endl;
        s = pthread_mutex_unlock(&mtx1);
        s = pthread_mutex_unlock(&mtx2);
    }
    pthread_exit(NULL);
}

void* flow(void *arg) {
    MyQueue *q = (MyQueue*)arg;
    int addedT = 0;		// Token added into the queue in this round
    int genT = 0;
    while (servedT < maxT) {	// Token in queue not equal to max Token
        sleep(flowInterval);
        srand(time(NULL));
        genT = (rand() % 10) + 1;		// randomly generated Token
        s = pthread_mutex_lock(&mtx1);	// critical section
        s = pthread_mutex_lock(&mtx2);
        addedT = q->push(genT);	// Tokens added into queue in this round
        totalGenT += genT;
        cout << addedT << " (flow )\t\t" << q->getSeqNum() << "\t\t\t" << q->getSize() << endl;
        s = pthread_mutex_unlock(&mtx1);
        s = pthread_mutex_unlock(&mtx2);
    }
    pthread_exit(NULL);
}

void* server(void *arg) {
    MyQueue *q = (MyQueue*)arg;
    int fetchT = 0;
    while (servedT < maxT) {
        sleep(2);
        srand(time(NULL));
        fetchT = (rand() % 20) + 1;
        if (fetchT > q->getSize()) { // token larger than queue size
            fetchT = q->getSize();
        }
        s = pthread_mutex_lock(&mtx1); // critical section
        if (q->isEmpty())	// When queue is empty
            fetchT = 0;
        fetchT = q->pop(fetchT); // token fetched in this round
        cout << fetchT << endl;
        if (q->isEmpty())
            sem_post(&empty);
        cout << "\t\t\t\t\t\t" << currentT << "\t\t" << fetchT << "\t\t" << totalFetchT << endl;
        s = pthread_mutex_unlock(&mtx1);
    }
    sem_post(&empty);
    pthread_exit(NULL);
}


int main(int argc, char * argv[]) {
    MyQueue q;
    if (argc == 3) {
        maxT = atoi(argv[1]);
        flowInterval = atoi(argv[2]);
    } else {
        cout << "Insufficient argument" << endl;
        exit(-1);
    }
    sem_init(&empty, 0, 0);
    pthread_t flowT, serverT, pFlowT;
    int i, rc;
    printf("The Max Token is %d and the interval time for flow is %d\n", maxT, flowInterval);
    cout << "Flow\t\t\t\t\t" << "Queue\t\t" << "Server" << endl;
    cout << "Token added\t" << "Last sequence number\t" << "Current Length\t" << "Token fetched\t" << "Total Token fetched" << endl;
    rc = pthread_create(&flowT, NULL, flow, (void*)&q);
    if (rc) {
        cout << "Error when creating flow thread!" << endl;
        exit(-1);
    }
    rc = pthread_create(&serverT, NULL, server, (void*)&q);
    if (rc) {
        cout << "Error when creating server thread!" << endl;
        exit(-1);
    }
    rc = pthread_create(&pFlowT, NULL, pflow, (void*)&q);
    if (rc) {
        cout << "Error when creating server thread!" << endl;
        exit(-1);
    }
    rc = pthread_join(flowT, NULL);
    if (rc) {
        cout << "Error when joining flow thread!" << endl;
        exit(-1);
    }
    rc = pthread_join(serverT, NULL);
    if (rc) {
        cout << "Error when joining server thread!" << endl;
        exit(-1);
    }
    rc = pthread_join(pFlowT, NULL);
    if (rc) {
        cout << "Error when joining flow thread!" << endl;
        exit(-1);
    }
    cout << "The total number of tokens that have been fetched by the server is " << totalFetchT << endl;
    cout << "The total number of tokens that have been generated by the flow is " << totalGenT << endl;
    cout << "The total number of tokens that have been generated by the pflow is " << totalPGenT << endl;
    cout << "The total number of tokens that have been dropped by the queue is " << dropT << endl;
    sem_destroy(&empty);
    pthread_exit(NULL);

}




