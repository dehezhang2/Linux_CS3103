#include <iostream>
#include <cstdlib>
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <ctime>
#include <stdio.h>
#include <semaphore.h>

using namespace std;
static int maxT = 0,	// max Token
           flowInterval = 0,	//sleep interval time
           currentT = 0,	// current Token in queue
           servedT = 0,	// served Token
           dropT = 0,	// dropped Token
           totalFetchT = 0,	// total fetched Token
           totalGenT = 0,	// total generated Token
           totalPGenT = 0; // total token generated by pflow
int s;	// for mutex
int seqNum = 0;
sem_t empty;
static pthread_mutex_t mtx1 = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t mtx2 = PTHREAD_MUTEX_INITIALIZER;

class MyQueue {
private:
    int capacity, front, rear, size,seqNum;
    int *queue;
public:
    MyQueue() {
        queue = new int[50];
        front = 0;
        rear = 0;
        capacity = 11;
        size = 0;
    }
    void push(int seq) {
        queue[rear] = seq;
        rear = (rear+1)%capacity;
        size++;
    }

    void pop() {
        front = (front+1)%capacity;
        size--;
    }
    bool isEmpty() {
        return (front == rear);
    }
    bool isFull() {
        return ((rear + 1) % capacity == front);
    }
    int getSize() {
        return size;
    }
};

void* pflow(void *arg) {
    MyQueue *q = (MyQueue*)arg;
    int addedT = 0;
    int genT = 0;
    while (dropT+totalFetchT < maxT) {
        sem_wait(&empty);
        if (servedT >= maxT) {
            pthread_exit(NULL);
        }
        // sem_wait(&empty);
        srand(time(NULL));
        genT = (rand() % 5) + 1;
        s = pthread_mutex_lock(&mtx1);
        s = pthread_mutex_lock(&mtx2);
        
        totalGenT += genT;
        for(int i=0;i<genT;i++){
            if(dropT + totalFetchT >= maxT) break;
            if(!q->isFull()){
                q->push(seqNum);
            }
            else dropT++;
            seqNum++;
        }

        cout << genT << " (pflow)\t\t" << seqNum << "\t\t\t" << q->getSize() << endl;
        s = pthread_mutex_unlock(&mtx1);
        s = pthread_mutex_unlock(&mtx2);
    }
    pthread_exit(NULL);
}

void* flow(void *arg) {
    MyQueue *q = (MyQueue*)arg;
    int addedT = 0;		// Token added into the queue in this round
    int genT = 0;
    while (dropT + totalFetchT < maxT) {	// Token in queue not equal to max Token
        sleep(flowInterval);
        srand(time(NULL));
        genT = (rand() % 10) + 1;		// randomly generated Token
        s = pthread_mutex_lock(&mtx1);	// critical section
        s = pthread_mutex_lock(&mtx2);

        totalGenT += genT;
        for(int i=0;i<genT;i++){
            if(dropT + totalFetchT >= maxT) break;
            if(!q->isFull()){
                q->push(seqNum);
            }
            else dropT++;
            seqNum++;
        }

        cout << genT << " (flow )\t\t" << seqNum << "\t\t\t" << q->getSize() << endl;
        s = pthread_mutex_unlock(&mtx1);
        s = pthread_mutex_unlock(&mtx2);
    }
    pthread_exit(NULL);
}

void* server(void *arg) {
    MyQueue *q = (MyQueue*)arg;
    int fetchT = 0;
    while (dropT + totalFetchT < maxT) {
        sleep(2);
        srand(time(NULL));
        fetchT = (rand() % 20) + 1;
        if (fetchT > q->getSize()) { // token larger than queue size
            fetchT = q->getSize();
        }
        s = pthread_mutex_lock(&mtx1); // critical section
        for(int cnt = 0; cnt < fetchT; cnt++) {
            if(dropT + totalFetchT >= maxT)break;
            if(!q->isEmpty()){
                q->pop();
                totalFetchT++;
            } else break;

        }
        
        if (q->isEmpty())
            sem_post(&empty);
        cout << "\t\t\t\t\t\t" << q -> getSize() << "\t\t" << fetchT << "\t\t" << totalFetchT << endl;
        s = pthread_mutex_unlock(&mtx1);
    }
    sem_post(&empty);
    pthread_exit(NULL);
}


int main(int argc, char * argv[]) {
    MyQueue q;
    if (argc == 3) {
        maxT = atoi(argv[1]);
        flowInterval = atoi(argv[2]);
    } else {
        cout << "Insufficient argument" << endl;
        exit(-1);
    }
    sem_init(&empty, 0, 0);
    pthread_t flowT, serverT, pFlowT;
    int i, rc;
    printf("The Max Token is %d and the interval time for flow is %d\n", maxT, flowInterval);
    cout << "Flow\t\t\t\t\t" << "Queue\t\t" << "Server" << endl;
    cout << "Token added\t" << "Last sequence number\t" << "Current Length\t" << "Token fetched\t" << "Total Token fetched" << endl;
    rc = pthread_create(&flowT, NULL, flow, (void*)&q);
    if (rc) {
        cout << "Error when creating flow thread!" << endl;
        exit(-1);
    }
    rc = pthread_create(&serverT, NULL, server, (void*)&q);
    if (rc) {
        cout << "Error when creating server thread!" << endl;
        exit(-1);
    }
    rc = pthread_create(&pFlowT, NULL, pflow, (void*)&q);
    if (rc) {
        cout << "Error when creating server thread!" << endl;
        exit(-1);
    }
    rc = pthread_join(flowT, NULL);
    if (rc) {
        cout << "Error when joining flow thread!" << endl;
        exit(-1);
    }
    rc = pthread_join(serverT, NULL);
    if (rc) {
        cout << "Error when joining server thread!" << endl;
        exit(-1);
    }
    rc = pthread_join(pFlowT, NULL);
    if (rc) {
        cout << "Error when joining flow thread!" << endl;
        exit(-1);
    }
    cout << "The total number of tokens that have been fetched by the server is " << totalFetchT << endl;
    cout << "The total number of tokens that have been generated by the flow is " << totalGenT << endl;
    cout << "The total number of tokens that have been generated by the pflow is " << totalPGenT << endl;
    cout << "The total number of tokens that have been dropped by the queue is " << dropT << endl;
    sem_destroy(&empty);
    pthread_exit(NULL);

}




